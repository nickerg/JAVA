1.方法：一段可重复调用的代码段。
```java
访问修饰符  返回值类型  方法名(){
  方法主体
}
```
2.方法的重载：方法名称相同，但是参数的类型和个数不同，通过传递参数的个数和烃开不同来完成不同的功能。

3.类的定义、声明和使用
```
class 类名称{
  属性
  方法
}
```
- 声明一个类需要通过关键字`class`
- 类名的首字母要大写
- 类是对某一类事物的描述，是抽象的、概念上的
- 对象是实际存在的该类事物的每一个个体

4.面向对象的三大特征
- 封闭性。对外部不可见。
- 继承。扩展类的功能。
- 多态性。方法的重载，对象的多态性。

5.封装性
- 产生目的：保护某些属性和方法不被外部所看见
- 实现：通过关键字private声明。实现该属性的set和get方法，为外部所访问。

6.匿名对象
- 匿名对象就是没有名字的对象，如果程序中只使用一次该对象，就可以使用匿名对象的方式。
- new Person.tell();

7.构造方法
```
访问修饰符  类名称{
  程序语句
}
```
- 构造方法名称必须与类名一致
- 构造方法没有返回值
- 主要是为类中的属性初始化
- 每个类在实例化后都会调用构造方法。如果没有构造方法，程序在编译的时候会创建一个无参的什么都不做的构造方法。

8.引用
- 对象存储的是指向堆空间的具体类的引用，类中的string引用的地址在堆空间中，可更改。
- string的栈空间存储的是指向堆空间的地址，不可更改

9.this关键字
- 表示类中的属性和调用方法
- 调用本类中的构造方法，必须放在构造方法的首行
- 表示当前对象

10.static关键字
- static声明全局属性
- static声明方法，直接通过类名调用
- 使用static方法的时候，只能访问static声明的属性和方法，而非static声明的属性和方法是不能访问的
- 静态属性和方法最好通过类名调用
- 表示公有的，

11.继承
- 继承：扩展父类的功能
- 使用extends完成继承。`class 子类 extends 父类 {}`

12.继承的限制
- Java中只允许单继承。即只能继承一个类，但可以多层次继承
- 子类不能直接访问父类的私有成员及方法

13.子类对象的实例化
- 在子类对象实例化之前，必须先调用父类中的构造方法，然后调用子类构造方法

14.方法的重写
- 重写：子类定义了和父类同名的方法
- 方法名称相同，返回值类型相同，参数也相同。可以用supper调用父类方法
- 重写限制：被子类重写的方法不能拥有比父类方法更严格的访问权限
- 访问权限：private < default < public。只能在当前类下进行访问；在当前包下进行访问；在整个工程下进行访问。

15.super关键字
- 强行调用父类方法的执行
- 在子类的构造方法的第一行自动添加supper的调用。
- 可以在重写中使用，也可以表示方法为从父类中继承。

16.重载与重写的区别
|重载|重写|
|:=:|:=:|
|Overloading|Overriding|
|方法名称相同，参数的类型或个数不同|方法名称、参数的类型、返回值类型全部相同|
|对权限没有要求|被重写的方法不能拥有比父类更加严格的权限|
|发生在一个类中|发生在继承中|

17.final关键字
- 在Java中被称为完结器，表示最终的意思。
- 能声明类、方法、属性：
- 使用final声明的类不能被继承
- 使用final声明的方法不能被重写
- 使用final声明的变量变成常量，常量是不可以被修改的
- 被final修饰的变量，变量名全部使用大写

18.抽象类
- 抽象类：包含一个抽象方法的类就是抽象类
- 抽象方法：声明而未被实现的方法，抽象方法必须使用abstract进行声明
- 抽象类被子类继承，子类（如果不是抽象类）必须重写抽象类中的所有方法
- 抽象类不能直接实例化，要通过其子类进行实例化

19.接口
- 可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成
- `interface interfaceName{全局常量\n 抽象方法}`
- 全局常量：public static final type NAME = value;
- 抽象方法：public abstract void tell();
- 接口的实现也必须通过子类，使用关键字implements，而且接口是可以多实现的
- 一个类可以同时继承抽象类和实现接口
- 一个接口不能继承一个抽象类，但可以通过extends同时继承多个接口，实现接口的多继承

20.多态性
- 方法和重载和重写
- 对象的多态性
  - 向上转型：程序会自动完成。父类 父类对象=子类实例。只能调用父类中的方法及属性，如果子类重写了父类方法，则调用的是子类的方法。
  - 向下转型：强制类型转换。  子类 子类对象=（子类）父类实例。必须先发生向上转型。

21.instanceof
- 用来判断一个对象到底是不是一个类的实例

22.泛型
- 可以解决数据类型的安全性问题。在类声明的时候通过一个标识表示类中的某个属性的类型或者是某个方法的返回值及参数类型。
- `访问权限 class 类名称<泛型，泛型……>{属性 方法}`
- 对象的创建。`类名称<具体类型> 对象名称= new 类名称<具体类型>();

23.构造方法中使用泛型
- 如果类中的属性通过泛型指定，而又需要通过构造方法设置属性内容的时候，那么构造方法的定义与之前并无不同，不需要像声明类那样指定泛型。

24.泛型接口。类似泛型类

25.泛型方法。
- 可以定义泛型参数，此时，参数的类型就是传入数据类型。
- `访问权限 <泛型标识> 泛型标识 方法名称([泛型标识 参数名称])`

泛型即，可以适配不同类型的参数
